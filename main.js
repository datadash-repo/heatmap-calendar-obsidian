/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => HeatmapCalendar
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  year: new Date().getFullYear(),
  colors: {
    default: ["#c6e48b", "#7bc96f", "#49af5d", "#2e8840", "#196127"]
  },
  entries: [{ date: "1900-01-01", color: "#7bc96f", intensity: 5, content: "" }],
  showCurrentDayBorder: true,
  defaultEntryIntensity: 4,
  intensityScaleStart: 1,
  intensityScaleEnd: 5
};
var HeatmapCalendar = class extends import_obsidian.Plugin {
  getHowManyDaysIntoYear(date) {
    return (Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate()) - Date.UTC(date.getUTCFullYear(), 0, 0)) / 24 / 60 / 60 / 1e3;
  }
  getHowManyDaysIntoYearLocal(date) {
    return (Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()) - Date.UTC(date.getFullYear(), 0, 0)) / 24 / 60 / 60 / 1e3;
  }
  removeHtmlElementsNotInYear(entries, year) {
    var _a;
    const calEntriesNotInDisplayedYear = (_a = entries.filter((e) => new Date(e.date).getFullYear() !== year)) != null ? _a : this.settings.entries;
    calEntriesNotInDisplayedYear.forEach((e) => e.content instanceof HTMLElement && e.content.remove());
  }
  clamp(input, min, max) {
    return input < min ? min : input > max ? max : input;
  }
  map(current, inMin, inMax, outMin, outMax) {
    const mapped = (current - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;
    return this.clamp(mapped, outMin, outMax);
  }
  onload() {
    return __async(this, null, function* () {
      yield this.loadSettings();
      window.renderHeatmapCalendar = (el, calendarData) => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
        const year = (_a = calendarData.year) != null ? _a : this.settings.year;
        const colors = (_b = calendarData.colors) != null ? _b : this.settings.colors;
        this.removeHtmlElementsNotInYear(calendarData.entries, year);
        const calEntries = (_c = calendarData.entries.filter((e) => new Date(e.date + "T00:00").getFullYear() === year)) != null ? _c : this.settings.entries;
        const showCurrentDayBorder = (_d = calendarData.showCurrentDayBorder) != null ? _d : this.settings.showCurrentDayBorder;
        const defaultEntryIntensity = (_e = calendarData.defaultEntryIntensity) != null ? _e : this.settings.defaultEntryIntensity;
        const intensities = calEntries.filter((e) => e.intensity).map((e) => e.intensity);
        const minimumIntensity = intensities.length ? Math.min(...intensities) : this.settings.intensityScaleStart;
        const maximumIntensity = intensities.length ? Math.max(...intensities) : this.settings.intensityScaleEnd;
        const intensityScaleStart = (_f = calendarData.intensityScaleStart) != null ? _f : minimumIntensity;
        const intensityScaleEnd = (_g = calendarData.intensityScaleEnd) != null ? _g : maximumIntensity;
        const mappedEntries = [];
        calEntries.forEach((e) => {
          var _a2;
          const newEntry = __spreadValues({
            intensity: defaultEntryIntensity
          }, e);
          const colorIntensities = (_a2 = colors[e.color]) != null ? _a2 : colors[Object.keys(colors)[0]];
          const numOfColorIntensities = Object.keys(colorIntensities).length;
          if (minimumIntensity === maximumIntensity && intensityScaleStart === intensityScaleEnd)
            newEntry.intensity = numOfColorIntensities;
          else
            newEntry.intensity = Math.round(this.map(newEntry.intensity, intensityScaleStart, intensityScaleEnd, 1, numOfColorIntensities));
          mappedEntries[this.getHowManyDaysIntoYear(new Date(e.date))] = newEntry;
        });
        const firstDayOfYear = new Date(Date.UTC(year, 0, 1));
        let numberOfEmptyDaysBeforeYearBegins = (firstDayOfYear.getUTCDay() + 6) % 7;
        const boxes = [];
        while (numberOfEmptyDaysBeforeYearBegins) {
          boxes.push({ backgroundColor: "transparent" });
          numberOfEmptyDaysBeforeYearBegins--;
        }
        const lastDayOfYear = new Date(Date.UTC(year, 11, 31));
        const numberOfDaysInYear = this.getHowManyDaysIntoYear(lastDayOfYear);
        const todaysDayNumberLocal = this.getHowManyDaysIntoYearLocal(new Date());
        for (let day = 1; day <= numberOfDaysInYear; day++) {
          const box = {
            classNames: []
          };
          if (day === todaysDayNumberLocal && showCurrentDayBorder)
            (_h = box.classNames) == null ? void 0 : _h.push("today");
          if (mappedEntries[day]) {
            (_i = box.classNames) == null ? void 0 : _i.push("hasData");
            const entry = mappedEntries[day];
            box.date = entry.date;
            if (entry.content)
              box.content = entry.content;
            const currentDayColors = entry.color ? colors[entry.color] : colors[Object.keys(colors)[0]];
            box.backgroundColor = currentDayColors[entry.intensity - 1];
          } else
            (_j = box.classNames) == null ? void 0 : _j.push("isEmpty");
          boxes.push(box);
        }
        const heatmapCalendarGraphDiv = createDiv({
          cls: "heatmap-calendar-graph",
          parent: el
        });
        createDiv({
          cls: "heatmap-calendar-year",
          text: String(year).slice(2),
          parent: heatmapCalendarGraphDiv
        });
        const heatmapCalendarMonthsUl = createEl("ul", {
          cls: "heatmap-calendar-months",
          parent: heatmapCalendarGraphDiv
        });
        createEl("li", { text: "Jan", parent: heatmapCalendarMonthsUl });
        createEl("li", { text: "Feb", parent: heatmapCalendarMonthsUl });
        createEl("li", { text: "Mar", parent: heatmapCalendarMonthsUl });
        createEl("li", { text: "Apr", parent: heatmapCalendarMonthsUl });
        createEl("li", { text: "May", parent: heatmapCalendarMonthsUl });
        createEl("li", { text: "Jun", parent: heatmapCalendarMonthsUl });
        createEl("li", { text: "Jul", parent: heatmapCalendarMonthsUl });
        createEl("li", { text: "Aug", parent: heatmapCalendarMonthsUl });
        createEl("li", { text: "Sep", parent: heatmapCalendarMonthsUl });
        createEl("li", { text: "Oct", parent: heatmapCalendarMonthsUl });
        createEl("li", { text: "Nov", parent: heatmapCalendarMonthsUl });
        createEl("li", { text: "Dec", parent: heatmapCalendarMonthsUl });
        const heatmapCalendarDaysUl = createEl("ul", {
          cls: "heatmap-calendar-days",
          parent: heatmapCalendarGraphDiv
        });
        createEl("li", { text: "Mon", parent: heatmapCalendarDaysUl });
        createEl("li", { text: "Tue", parent: heatmapCalendarDaysUl });
        createEl("li", { text: "Wed", parent: heatmapCalendarDaysUl });
        createEl("li", { text: "Thu", parent: heatmapCalendarDaysUl });
        createEl("li", { text: "Fri", parent: heatmapCalendarDaysUl });
        createEl("li", { text: "Sat", parent: heatmapCalendarDaysUl });
        createEl("li", { text: "Sun", parent: heatmapCalendarDaysUl });
        const heatmapCalendarBoxesUl = createEl("ul", {
          cls: "heatmap-calendar-boxes",
          parent: heatmapCalendarGraphDiv
        });
        boxes.forEach((e) => {
          createEl("li", {
            text: e.content,
            attr: __spreadValues({}, e.backgroundColor && { style: `background-color: ${e.backgroundColor};` }),
            cls: e.classNames,
            parent: heatmapCalendarBoxesUl
          });
        });
      };
    });
  }
  onunload() {
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
    });
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibWFpbi50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiaW1wb3J0IHsgUGx1Z2luLCB9IGZyb20gJ29ic2lkaWFuJ1xuXG5pbnRlcmZhY2UgQ2FsZW5kYXJEYXRhIHtcblx0eWVhcjogbnVtYmVyXG5cdGNvbG9yczoge1xuXHRcdFtpbmRleDogc3RyaW5nIHwgbnVtYmVyXToge1xuXHRcdFx0W2luZGV4OiBudW1iZXJdOiBzdHJpbmdcblx0XHR9XG5cdH1cblx0ZW50cmllczogRW50cnlbXVxuXHRzaG93Q3VycmVudERheUJvcmRlcjogYm9vbGVhblxuXHRkZWZhdWx0RW50cnlJbnRlbnNpdHk6IG51bWJlclxuXHRpbnRlbnNpdHlTY2FsZVN0YXJ0OiBudW1iZXJcblx0aW50ZW5zaXR5U2NhbGVFbmQ6IG51bWJlclxufVxuaW50ZXJmYWNlIEVudHJ5IHtcblx0ZGF0ZTogc3RyaW5nXG5cdGludGVuc2l0eT86IG51bWJlclxuXHRjb2xvcjogc3RyaW5nIFxuXHRjb250ZW50OiBzdHJpbmdcbn1cbmNvbnN0IERFRkFVTFRfU0VUVElOR1M6IENhbGVuZGFyRGF0YSA9IHtcblx0eWVhcjogbmV3IERhdGUoKS5nZXRGdWxsWWVhcigpLFxuXHRjb2xvcnM6IHtcblx0XHRkZWZhdWx0OiBbXCIjYzZlNDhiXCIsIFwiIzdiYzk2ZlwiLCBcIiM0OWFmNWRcIiwgXCIjMmU4ODQwXCIsIFwiIzE5NjEyN1wiLF0sXG5cdH0sXG5cdGVudHJpZXM6IFt7IGRhdGU6IFwiMTkwMC0wMS0wMVwiLCBjb2xvcjogXCIjN2JjOTZmXCIsIGludGVuc2l0eTogNSwgY29udGVudDogXCJcIix9LF0sXG5cdHNob3dDdXJyZW50RGF5Qm9yZGVyOiB0cnVlLFxuXHRkZWZhdWx0RW50cnlJbnRlbnNpdHk6IDQsXG5cdGludGVuc2l0eVNjYWxlU3RhcnQ6IDEsXG5cdGludGVuc2l0eVNjYWxlRW5kOiA1LFxufVxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSGVhdG1hcENhbGVuZGFyIGV4dGVuZHMgUGx1Z2luIHtcblxuXHRzZXR0aW5nczogQ2FsZW5kYXJEYXRhXG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBudW1iZXIgcmVwcmVzZW50aW5nIGhvdyBtYW55IGRheXMgaW50byB0aGUgeWVhciB0aGUgc3VwcGxpZWQgZGF0ZSBpcy4gXG5cdCAqIEV4YW1wbGU6IGZpcnN0IG9mIGphbnVhcnkgaXMgMSwgdGhpcmQgb2YgZmVicnVhcnkgaXMgMzQgKDMxKzMpIFxuXHQgKiBAcGFyYW0gZGF0ZVxuXHQgKi9cblx0XG5cdGdldEhvd01hbnlEYXlzSW50b1llYXIoZGF0ZTogRGF0ZSk6IG51bWJlciB7XG5cdFx0cmV0dXJuIChcblx0XHRcdChEYXRlLlVUQyhkYXRlLmdldFVUQ0Z1bGxZZWFyKCksIGRhdGUuZ2V0VVRDTW9udGgoKSwgZGF0ZS5nZXRVVENEYXRlKCkpIC1cblx0XHRcdFx0RGF0ZS5VVEMoZGF0ZS5nZXRVVENGdWxsWWVhcigpLCAwLCAwKSkgLyAyNCAvIDYwIC8gNjAgLyAxMDAwXG5cdFx0KVxuXHR9XG5cdGdldEhvd01hbnlEYXlzSW50b1llYXJMb2NhbChkYXRlOiBEYXRlKTogbnVtYmVyIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0KERhdGUuVVRDKGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpLCBkYXRlLmdldERhdGUoKSkgLVxuXHRcdFx0XHREYXRlLlVUQyhkYXRlLmdldEZ1bGxZZWFyKCksIDAsIDApKSAvIDI0IC8gNjAgLyA2MCAvIDEwMDBcblx0XHQpXG5cdH1cblx0LyoqIFxuXHQgKiBSZW1vdmVzIEhUTUxFbGVtZW50cyBwYXNzZWQgYXMgZW50cnkuY29udGVudCBhbmQgb3V0c2lkZSBvZiB0aGUgZGlzcGxheWVkIHllYXIgZnJvbSByZW5kZXJpbmcgYWJvdmUgdGhlIGNhbGVuZGFyXG5cdCAqL1xuXHRyZW1vdmVIdG1sRWxlbWVudHNOb3RJblllYXIoZW50cmllczogRW50cnlbXSwgeWVhcjogbnVtYmVyKSB7XG5cdFx0Y29uc3QgY2FsRW50cmllc05vdEluRGlzcGxheWVkWWVhciA9IGVudHJpZXMuZmlsdGVyKGUgPT4gbmV3IERhdGUoZS5kYXRlKS5nZXRGdWxsWWVhcigpICE9PSB5ZWFyKSA/PyB0aGlzLnNldHRpbmdzLmVudHJpZXNcblx0XHQvL0B0cy1pZ25vcmVcblx0XHRjYWxFbnRyaWVzTm90SW5EaXNwbGF5ZWRZZWFyLmZvckVhY2goZSA9PiBlLmNvbnRlbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJiBlLmNvbnRlbnQucmVtb3ZlKCkpXG5cdH1cblxuXHRjbGFtcChpbnB1dDogbnVtYmVyLCBtaW46IG51bWJlciwgbWF4OiBudW1iZXIpOiBudW1iZXIge1xuXHRcdHJldHVybiBpbnB1dCA8IG1pbiA/IG1pbiA6IGlucHV0ID4gbWF4ID8gbWF4IDogaW5wdXRcblx0fVxuXG5cdG1hcChjdXJyZW50OiBudW1iZXIsIGluTWluOiBudW1iZXIsIGluTWF4OiBudW1iZXIsIG91dE1pbjogbnVtYmVyLCBvdXRNYXg6IG51bWJlcik6IG51bWJlciB7XG5cdFx0Y29uc3QgbWFwcGVkOiBudW1iZXIgPSAoKGN1cnJlbnQgLSBpbk1pbikgKiAob3V0TWF4IC0gb3V0TWluKSkgLyAoaW5NYXggLSBpbk1pbikgKyBvdXRNaW5cblx0XHRyZXR1cm4gdGhpcy5jbGFtcChtYXBwZWQsIG91dE1pbiwgb3V0TWF4KVxuXHR9XG5cblx0YXN5bmMgb25sb2FkKCkge1xuXG5cdFx0YXdhaXQgdGhpcy5sb2FkU2V0dGluZ3MoKVxuXG5cdFx0Ly9AdHMtaWdub3JlXG5cdFx0d2luZG93LnJlbmRlckhlYXRtYXBDYWxlbmRhciA9IChlbDogSFRNTEVsZW1lbnQsIGNhbGVuZGFyRGF0YTogQ2FsZW5kYXJEYXRhKTogdm9pZCA9PiB7XG5cblx0XHRcdGNvbnN0IHllYXIgPSBjYWxlbmRhckRhdGEueWVhciA/PyB0aGlzLnNldHRpbmdzLnllYXJcblx0XHRcdGNvbnN0IGNvbG9ycyA9IGNhbGVuZGFyRGF0YS5jb2xvcnMgPz8gdGhpcy5zZXR0aW5ncy5jb2xvcnNcblxuXHRcdFx0dGhpcy5yZW1vdmVIdG1sRWxlbWVudHNOb3RJblllYXIoY2FsZW5kYXJEYXRhLmVudHJpZXMsIHllYXIpXG5cblx0XHRcdGNvbnN0IGNhbEVudHJpZXMgPSBjYWxlbmRhckRhdGEuZW50cmllcy5maWx0ZXIoZSA9PiBuZXcgRGF0ZShlLmRhdGUgKyBcIlQwMDowMFwiKS5nZXRGdWxsWWVhcigpID09PSB5ZWFyKSA/PyB0aGlzLnNldHRpbmdzLmVudHJpZXNcblxuXHRcdFx0Y29uc3Qgc2hvd0N1cnJlbnREYXlCb3JkZXIgPSBjYWxlbmRhckRhdGEuc2hvd0N1cnJlbnREYXlCb3JkZXIgPz8gdGhpcy5zZXR0aW5ncy5zaG93Q3VycmVudERheUJvcmRlclxuXG5cdFx0XHRjb25zdCBkZWZhdWx0RW50cnlJbnRlbnNpdHkgPSBjYWxlbmRhckRhdGEuZGVmYXVsdEVudHJ5SW50ZW5zaXR5ID8/IHRoaXMuc2V0dGluZ3MuZGVmYXVsdEVudHJ5SW50ZW5zaXR5XG5cblx0XHRcdGNvbnN0IGludGVuc2l0aWVzID0gY2FsRW50cmllcy5maWx0ZXIoZSA9PiBlLmludGVuc2l0eSkubWFwKGUgPT4gZS5pbnRlbnNpdHkgYXMgbnVtYmVyKVxuXHRcdFx0Y29uc3QgbWluaW11bUludGVuc2l0eSA9IGludGVuc2l0aWVzLmxlbmd0aCA/IE1hdGgubWluKC4uLmludGVuc2l0aWVzKSA6IHRoaXMuc2V0dGluZ3MuaW50ZW5zaXR5U2NhbGVTdGFydFxuXHRcdFx0Y29uc3QgbWF4aW11bUludGVuc2l0eSA9IGludGVuc2l0aWVzLmxlbmd0aCA/IE1hdGgubWF4KC4uLmludGVuc2l0aWVzKSA6IHRoaXMuc2V0dGluZ3MuaW50ZW5zaXR5U2NhbGVFbmRcblx0XHRcdGNvbnN0IGludGVuc2l0eVNjYWxlU3RhcnQgPSBjYWxlbmRhckRhdGEuaW50ZW5zaXR5U2NhbGVTdGFydCA/PyBtaW5pbXVtSW50ZW5zaXR5XG5cdFx0XHRjb25zdCBpbnRlbnNpdHlTY2FsZUVuZCA9IGNhbGVuZGFyRGF0YS5pbnRlbnNpdHlTY2FsZUVuZCA/PyBtYXhpbXVtSW50ZW5zaXR5XG5cblx0XHRcdGNvbnN0IG1hcHBlZEVudHJpZXM6IEVudHJ5W10gPSBbXVxuXHRcdFx0Y2FsRW50cmllcy5mb3JFYWNoKGUgPT4ge1xuXHRcdFx0XHRjb25zdCBuZXdFbnRyeSA9IHtcblx0XHRcdFx0XHRpbnRlbnNpdHk6IGRlZmF1bHRFbnRyeUludGVuc2l0eSxcblx0XHRcdFx0XHQuLi5lLFxuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnN0IGNvbG9ySW50ZW5zaXRpZXMgPSBjb2xvcnNbZS5jb2xvcl0gPz8gY29sb3JzW09iamVjdC5rZXlzKGNvbG9ycylbMF1dXG5cdFx0XHRcdGNvbnN0IG51bU9mQ29sb3JJbnRlbnNpdGllcyA9IE9iamVjdC5rZXlzKGNvbG9ySW50ZW5zaXRpZXMpLmxlbmd0aFxuXG5cdFx0XHRcdGlmKG1pbmltdW1JbnRlbnNpdHkgPT09IG1heGltdW1JbnRlbnNpdHkgJiYgaW50ZW5zaXR5U2NhbGVTdGFydCA9PT0gaW50ZW5zaXR5U2NhbGVFbmQpIG5ld0VudHJ5LmludGVuc2l0eSA9IG51bU9mQ29sb3JJbnRlbnNpdGllc1xuXHRcdFx0XHRlbHNlIG5ld0VudHJ5LmludGVuc2l0eSA9IE1hdGgucm91bmQodGhpcy5tYXAobmV3RW50cnkuaW50ZW5zaXR5LCBpbnRlbnNpdHlTY2FsZVN0YXJ0LCBpbnRlbnNpdHlTY2FsZUVuZCwgMSwgbnVtT2ZDb2xvckludGVuc2l0aWVzKSlcblxuXHRcdFx0XHRtYXBwZWRFbnRyaWVzW3RoaXMuZ2V0SG93TWFueURheXNJbnRvWWVhcihuZXcgRGF0ZShlLmRhdGUpKV0gPSBuZXdFbnRyeVxuXHRcdFx0fSlcblxuXHRcdFx0Y29uc3QgZmlyc3REYXlPZlllYXIgPSBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCAwLCAxKSlcblx0XHRcdGxldCBudW1iZXJPZkVtcHR5RGF5c0JlZm9yZVllYXJCZWdpbnMgPSAoZmlyc3REYXlPZlllYXIuZ2V0VVRDRGF5KCkgKyA2KSAlIDdcblxuXHRcdFx0aW50ZXJmYWNlIEJveCB7XG5cdFx0XHRcdGJhY2tncm91bmRDb2xvcj86IHN0cmluZztcblx0XHRcdFx0ZGF0ZT86IHN0cmluZztcblx0XHRcdFx0Y29udGVudD86IHN0cmluZztcblx0XHRcdFx0Y2xhc3NOYW1lcz86IHN0cmluZ1tdO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBib3hlczogQXJyYXk8Qm94PiA9IFtdXG5cblx0XHRcdHdoaWxlIChudW1iZXJPZkVtcHR5RGF5c0JlZm9yZVllYXJCZWdpbnMpIHtcblx0XHRcdFx0Ym94ZXMucHVzaCh7IGJhY2tncm91bmRDb2xvcjogXCJ0cmFuc3BhcmVudFwiLCB9KVxuXHRcdFx0XHRudW1iZXJPZkVtcHR5RGF5c0JlZm9yZVllYXJCZWdpbnMtLVxuXHRcdFx0fVxuXHRcdFx0Y29uc3QgbGFzdERheU9mWWVhciA9IG5ldyBEYXRlKERhdGUuVVRDKHllYXIsIDExLCAzMSkpXG5cdFx0XHRjb25zdCBudW1iZXJPZkRheXNJblllYXIgPSB0aGlzLmdldEhvd01hbnlEYXlzSW50b1llYXIobGFzdERheU9mWWVhcikgLy9lZyAzNjUgb3IgMzY2XG5cdFx0XHRjb25zdCB0b2RheXNEYXlOdW1iZXJMb2NhbCA9IHRoaXMuZ2V0SG93TWFueURheXNJbnRvWWVhckxvY2FsKG5ldyBEYXRlKCkpXG5cblx0XHRcdGZvciAobGV0IGRheSA9IDE7IGRheSA8PSBudW1iZXJPZkRheXNJblllYXI7IGRheSsrKSB7XG5cblx0XHRcdFx0Y29uc3QgYm94OiBCb3ggPSB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZXM6IFtdLFxuICAgICAgICAgICAgICAgIH1cblxuXHRcdFx0XHRpZiAoZGF5ID09PSB0b2RheXNEYXlOdW1iZXJMb2NhbCAmJiBzaG93Q3VycmVudERheUJvcmRlcikgYm94LmNsYXNzTmFtZXM/LnB1c2goXCJ0b2RheVwiKVxuXG5cdFx0XHRcdGlmIChtYXBwZWRFbnRyaWVzW2RheV0pIHtcblx0XHRcdFx0XHRib3guY2xhc3NOYW1lcz8ucHVzaChcImhhc0RhdGFcIilcblx0XHRcdFx0XHRjb25zdCBlbnRyeSA9IG1hcHBlZEVudHJpZXNbZGF5XVxuXG5cdFx0XHRcdFx0Ym94LmRhdGUgPSBlbnRyeS5kYXRlXG5cblx0XHRcdFx0XHRpZiAoZW50cnkuY29udGVudCkgYm94LmNvbnRlbnQgPSBlbnRyeS5jb250ZW50XG5cblx0XHRcdFx0XHRjb25zdCBjdXJyZW50RGF5Q29sb3JzID0gZW50cnkuY29sb3IgPyBjb2xvcnNbZW50cnkuY29sb3JdIDogY29sb3JzW09iamVjdC5rZXlzKGNvbG9ycylbMF1dXG5cdFx0XHRcdFx0Ym94LmJhY2tncm91bmRDb2xvciA9IGN1cnJlbnREYXlDb2xvcnNbZW50cnkuaW50ZW5zaXR5IGFzIG51bWJlciAtIDFdXG5cblx0XHRcdFx0fSBlbHNlIGJveC5jbGFzc05hbWVzPy5wdXNoKFwiaXNFbXB0eVwiKVxuXHRcdFx0XHRib3hlcy5wdXNoKGJveClcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgaGVhdG1hcENhbGVuZGFyR3JhcGhEaXYgPSBjcmVhdGVEaXYoe1xuXHRcdFx0XHRjbHM6IFwiaGVhdG1hcC1jYWxlbmRhci1ncmFwaFwiLFxuXHRcdFx0XHRwYXJlbnQ6IGVsLFxuXHRcdFx0fSlcblxuXHRcdFx0Y3JlYXRlRGl2KHtcblx0XHRcdFx0Y2xzOiBcImhlYXRtYXAtY2FsZW5kYXIteWVhclwiLFxuXHRcdFx0XHR0ZXh0OiBTdHJpbmcoeWVhcikuc2xpY2UoMiksXG5cdFx0XHRcdHBhcmVudDogaGVhdG1hcENhbGVuZGFyR3JhcGhEaXYsXG5cdFx0XHR9KVxuXG5cdFx0XHRjb25zdCBoZWF0bWFwQ2FsZW5kYXJNb250aHNVbCA9IGNyZWF0ZUVsKFwidWxcIiwge1xuXHRcdFx0XHRjbHM6IFwiaGVhdG1hcC1jYWxlbmRhci1tb250aHNcIixcblx0XHRcdFx0cGFyZW50OiBoZWF0bWFwQ2FsZW5kYXJHcmFwaERpdixcblx0XHRcdH0pXG5cblx0XHRcdGNyZWF0ZUVsKFwibGlcIiwgeyB0ZXh0OiBcIkphblwiLCBwYXJlbnQ6IGhlYXRtYXBDYWxlbmRhck1vbnRoc1VsLCB9KVxuXHRcdFx0Y3JlYXRlRWwoXCJsaVwiLCB7IHRleHQ6IFwiRmViXCIsIHBhcmVudDogaGVhdG1hcENhbGVuZGFyTW9udGhzVWwsIH0pXG5cdFx0XHRjcmVhdGVFbChcImxpXCIsIHsgdGV4dDogXCJNYXJcIiwgcGFyZW50OiBoZWF0bWFwQ2FsZW5kYXJNb250aHNVbCwgfSlcblx0XHRcdGNyZWF0ZUVsKFwibGlcIiwgeyB0ZXh0OiBcIkFwclwiLCBwYXJlbnQ6IGhlYXRtYXBDYWxlbmRhck1vbnRoc1VsLCB9KVxuXHRcdFx0Y3JlYXRlRWwoXCJsaVwiLCB7IHRleHQ6IFwiTWF5XCIsIHBhcmVudDogaGVhdG1hcENhbGVuZGFyTW9udGhzVWwsIH0pXG5cdFx0XHRjcmVhdGVFbChcImxpXCIsIHsgdGV4dDogXCJKdW5cIiwgcGFyZW50OiBoZWF0bWFwQ2FsZW5kYXJNb250aHNVbCwgfSlcblx0XHRcdGNyZWF0ZUVsKFwibGlcIiwgeyB0ZXh0OiBcIkp1bFwiLCBwYXJlbnQ6IGhlYXRtYXBDYWxlbmRhck1vbnRoc1VsLCB9KVxuXHRcdFx0Y3JlYXRlRWwoXCJsaVwiLCB7IHRleHQ6IFwiQXVnXCIsIHBhcmVudDogaGVhdG1hcENhbGVuZGFyTW9udGhzVWwsIH0pXG5cdFx0XHRjcmVhdGVFbChcImxpXCIsIHsgdGV4dDogXCJTZXBcIiwgcGFyZW50OiBoZWF0bWFwQ2FsZW5kYXJNb250aHNVbCwgfSlcblx0XHRcdGNyZWF0ZUVsKFwibGlcIiwgeyB0ZXh0OiBcIk9jdFwiLCBwYXJlbnQ6IGhlYXRtYXBDYWxlbmRhck1vbnRoc1VsLCB9KVxuXHRcdFx0Y3JlYXRlRWwoXCJsaVwiLCB7IHRleHQ6IFwiTm92XCIsIHBhcmVudDogaGVhdG1hcENhbGVuZGFyTW9udGhzVWwsIH0pXG5cdFx0XHRjcmVhdGVFbChcImxpXCIsIHsgdGV4dDogXCJEZWNcIiwgcGFyZW50OiBoZWF0bWFwQ2FsZW5kYXJNb250aHNVbCwgfSlcblxuXHRcdFx0Y29uc3QgaGVhdG1hcENhbGVuZGFyRGF5c1VsID0gY3JlYXRlRWwoXCJ1bFwiLCB7XG5cdFx0XHRcdGNsczogXCJoZWF0bWFwLWNhbGVuZGFyLWRheXNcIixcblx0XHRcdFx0cGFyZW50OiBoZWF0bWFwQ2FsZW5kYXJHcmFwaERpdixcblx0XHRcdH0pXG5cblx0XHRcdGNyZWF0ZUVsKFwibGlcIiwgeyB0ZXh0OiBcIk1vblwiLCBwYXJlbnQ6IGhlYXRtYXBDYWxlbmRhckRheXNVbCwgfSlcblx0XHRcdGNyZWF0ZUVsKFwibGlcIiwgeyB0ZXh0OiBcIlR1ZVwiLCBwYXJlbnQ6IGhlYXRtYXBDYWxlbmRhckRheXNVbCwgfSlcblx0XHRcdGNyZWF0ZUVsKFwibGlcIiwgeyB0ZXh0OiBcIldlZFwiLCBwYXJlbnQ6IGhlYXRtYXBDYWxlbmRhckRheXNVbCwgfSlcblx0XHRcdGNyZWF0ZUVsKFwibGlcIiwgeyB0ZXh0OiBcIlRodVwiLCBwYXJlbnQ6IGhlYXRtYXBDYWxlbmRhckRheXNVbCwgfSlcblx0XHRcdGNyZWF0ZUVsKFwibGlcIiwgeyB0ZXh0OiBcIkZyaVwiLCBwYXJlbnQ6IGhlYXRtYXBDYWxlbmRhckRheXNVbCwgfSlcblx0XHRcdGNyZWF0ZUVsKFwibGlcIiwgeyB0ZXh0OiBcIlNhdFwiLCBwYXJlbnQ6IGhlYXRtYXBDYWxlbmRhckRheXNVbCwgfSlcblx0XHRcdGNyZWF0ZUVsKFwibGlcIiwgeyB0ZXh0OiBcIlN1blwiLCBwYXJlbnQ6IGhlYXRtYXBDYWxlbmRhckRheXNVbCwgfSlcblxuXHRcdFx0Y29uc3QgaGVhdG1hcENhbGVuZGFyQm94ZXNVbCA9IGNyZWF0ZUVsKFwidWxcIiwge1xuXHRcdFx0XHRjbHM6IFwiaGVhdG1hcC1jYWxlbmRhci1ib3hlc1wiLFxuXHRcdFx0XHRwYXJlbnQ6IGhlYXRtYXBDYWxlbmRhckdyYXBoRGl2LFxuXHRcdFx0fSlcblxuXHRcdFx0Ym94ZXMuZm9yRWFjaChlID0+IHtcblx0XHRcdFx0Y3JlYXRlRWwoXCJsaVwiLCB7XG5cdFx0XHRcdFx0dGV4dDogZS5jb250ZW50LFxuXHRcdFx0XHRcdGF0dHI6IHtcblx0XHRcdFx0XHRcdC4uLmUuYmFja2dyb3VuZENvbG9yICYmIHsgc3R5bGU6IGBiYWNrZ3JvdW5kLWNvbG9yOiAke2UuYmFja2dyb3VuZENvbG9yfTtgLCB9LFxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0Y2xzOiBlLmNsYXNzTmFtZXMsXG5cdFx0XHRcdFx0cGFyZW50OiBoZWF0bWFwQ2FsZW5kYXJCb3hlc1VsLFxuXHRcdFx0XHR9KVxuXHRcdFx0fSlcblxuXHRcdH1cblx0fVxuXG5cdG9udW5sb2FkKCkge1xuXG5cdH1cblxuXHRhc3luYyBsb2FkU2V0dGluZ3MoKSB7XG5cdFx0dGhpcy5zZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfU0VUVElOR1MsIGF3YWl0IHRoaXMubG9hZERhdGEoKSlcblx0fVxuXG5cdGFzeW5jIHNhdmVTZXR0aW5ncygpIHtcblx0XHRhd2FpdCB0aGlzLnNhdmVEYXRhKHRoaXMuc2V0dGluZ3MpXG5cdH1cbn0iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLHNCQUF3QjtBQXFCeEIsSUFBTSxtQkFBaUM7QUFBQSxFQUN0QyxNQUFNLElBQUksS0FBSyxFQUFFLFlBQVk7QUFBQSxFQUM3QixRQUFRO0FBQUEsSUFDUCxTQUFTLENBQUMsV0FBVyxXQUFXLFdBQVcsV0FBVyxTQUFVO0FBQUEsRUFDakU7QUFBQSxFQUNBLFNBQVMsQ0FBQyxFQUFFLE1BQU0sY0FBYyxPQUFPLFdBQVcsV0FBVyxHQUFHLFNBQVMsR0FBRyxDQUFFO0FBQUEsRUFDOUUsc0JBQXNCO0FBQUEsRUFDdEIsdUJBQXVCO0FBQUEsRUFDdkIscUJBQXFCO0FBQUEsRUFDckIsbUJBQW1CO0FBQ3BCO0FBQ0EsSUFBcUIsa0JBQXJCLGNBQTZDLHVCQUFPO0FBQUEsRUFVbkQsdUJBQXVCLE1BQW9CO0FBQzFDLFdB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
